{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState } from \"react\";\nimport { timeLoading } from \"./constants\";\nexport const API = `${process.env.REACT_APP_API_URL}api`;\nexport const useHttp = () => {\n  _s();\n\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [errorsValid, setErrorsValid] = useState(null);\n  const request = useCallback(async _ref => {\n    let {\n      url,\n      method = 'GET',\n      body,\n      headers = {},\n      notJsonContent = false\n    } = _ref;\n    setLoading(true);\n    setErrorsValid(null);\n\n    try {\n      if (body && !notJsonContent) {\n        body = JSON.stringify(body);\n        headers['Content-Type'] = 'application/json';\n      }\n\n      const response = await fetch(`${API}/${url}`, {\n        method,\n        body,\n        headers\n      });\n      const data = await response.json();\n\n      if (!response.ok) {\n        var _data$errors;\n\n        const errors = (_data$errors = data.errors) === null || _data$errors === void 0 ? void 0 : _data$errors.map(error => ({\n          errorField: error.param,\n          errorText: error.msg\n        }));\n        setErrorsValid(errors);\n        throw new Error(data.message || 'Error Error!');\n      }\n\n      return data;\n    } catch (e) {\n      setError(e.message);\n      throw e;\n    } finally {\n      setTimeout(() => setLoading(false), timeLoading);\n    }\n  }, []);\n  const clearError = useCallback(() => {\n    setError(null);\n    setErrorsValid(null);\n  }, []);\n  return {\n    loading,\n    setLoading,\n    request,\n    error,\n    clearError,\n    errorsValid\n  };\n};\n\n_s(useHttp, \"1+cXD51lXvDVDu4v3tOK1mKdl+s=\");","map":{"version":3,"names":["useCallback","useState","timeLoading","API","process","env","REACT_APP_API_URL","useHttp","loading","setLoading","error","setError","errorsValid","setErrorsValid","request","url","method","body","headers","notJsonContent","JSON","stringify","response","fetch","data","json","ok","errors","map","errorField","param","errorText","msg","Error","message","e","setTimeout","clearError"],"sources":["/Users/ksena/Программирование/React/lessons/Shop_1001/client/src/hooks/http.hook.ts"],"sourcesContent":["import { useCallback, useState } from \"react\"\n\nimport { ErrorType } from \"../utils/ErrorsHanding\"\nimport { timeLoading } from \"./constants\"\n\ntype RequestType = {\n    url: string,\n    method?: string, \n    body?: any, \n    headers?: { [x: string]: string },\n    notJsonContent?: boolean\n}\n\ntype ErrorMapType = {\n    param: string,\n    msg: string,\n}\n\nexport const API = `${process.env.REACT_APP_API_URL}api`\n\nexport const useHttp = () => {\n    const [loading, setLoading] = useState(false)\n    const [error, setError] = useState(null)\n    const [errorsValid, setErrorsValid] = useState<ErrorType[] | null>(null)\n\n    const request = useCallback(async({ url, method = 'GET', body, headers = {}, notJsonContent = false }: RequestType) => {\n        setLoading(true)\n        setErrorsValid(null)\n\n        try {\n            if (body && !notJsonContent) {\n                body = JSON.stringify(body)\n                headers['Content-Type'] = 'application/json'\n            }\n\n            const response = await fetch(`${API}/${url}`, { method, body, headers })\n\n            const data = await response.json()\n\n            if (!response.ok) {\n                const errors = data.errors?.map((error: ErrorMapType) => ({\n                    errorField: error.param,\n                    errorText: error.msg\n                }))\n\n                setErrorsValid(errors)\n\n                throw new Error(data.message || 'Error Error!')\n            }\n\n            return data\n        } catch (e: any) {\n            setError(e.message)\n            throw e\n        } finally {\n            setTimeout(() => \n                setLoading(false)\n            , timeLoading) \n        }\n    }, [])\n\n    const clearError = useCallback(() => {\n        setError(null)\n        setErrorsValid(null)\n    }, [])\n    \n    return { loading, setLoading, request, error, clearError, errorsValid }\n}\n"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AAGA,SAASC,WAAT,QAA4B,aAA5B;AAeA,OAAO,MAAMC,GAAG,GAAI,GAAEC,OAAO,CAACC,GAAR,CAAYC,iBAAkB,KAA7C;AAEP,OAAO,MAAMC,OAAO,GAAG,MAAM;EAAA;;EACzB,MAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBR,QAAQ,CAAC,KAAD,CAAtC;EACA,MAAM,CAACS,KAAD,EAAQC,QAAR,IAAoBV,QAAQ,CAAC,IAAD,CAAlC;EACA,MAAM,CAACW,WAAD,EAAcC,cAAd,IAAgCZ,QAAQ,CAAqB,IAArB,CAA9C;EAEA,MAAMa,OAAO,GAAGd,WAAW,CAAC,cAA2F;IAAA,IAArF;MAAEe,GAAF;MAAOC,MAAM,GAAG,KAAhB;MAAuBC,IAAvB;MAA6BC,OAAO,GAAG,EAAvC;MAA2CC,cAAc,GAAG;IAA5D,CAAqF;IACnHV,UAAU,CAAC,IAAD,CAAV;IACAI,cAAc,CAAC,IAAD,CAAd;;IAEA,IAAI;MACA,IAAII,IAAI,IAAI,CAACE,cAAb,EAA6B;QACzBF,IAAI,GAAGG,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAP;QACAC,OAAO,CAAC,cAAD,CAAP,GAA0B,kBAA1B;MACH;;MAED,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAAE,GAAEpB,GAAI,IAAGY,GAAI,EAAf,EAAkB;QAAEC,MAAF;QAAUC,IAAV;QAAgBC;MAAhB,CAAlB,CAA5B;MAEA,MAAMM,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAAnB;;MAEA,IAAI,CAACH,QAAQ,CAACI,EAAd,EAAkB;QAAA;;QACd,MAAMC,MAAM,mBAAGH,IAAI,CAACG,MAAR,iDAAG,aAAaC,GAAb,CAAkBlB,KAAD,KAA0B;UACtDmB,UAAU,EAAEnB,KAAK,CAACoB,KADoC;UAEtDC,SAAS,EAAErB,KAAK,CAACsB;QAFqC,CAA1B,CAAjB,CAAf;QAKAnB,cAAc,CAACc,MAAD,CAAd;QAEA,MAAM,IAAIM,KAAJ,CAAUT,IAAI,CAACU,OAAL,IAAgB,cAA1B,CAAN;MACH;;MAED,OAAOV,IAAP;IACH,CAtBD,CAsBE,OAAOW,CAAP,EAAe;MACbxB,QAAQ,CAACwB,CAAC,CAACD,OAAH,CAAR;MACA,MAAMC,CAAN;IACH,CAzBD,SAyBU;MACNC,UAAU,CAAC,MACP3B,UAAU,CAAC,KAAD,CADJ,EAERP,WAFQ,CAAV;IAGH;EACJ,CAlC0B,EAkCxB,EAlCwB,CAA3B;EAoCA,MAAMmC,UAAU,GAAGrC,WAAW,CAAC,MAAM;IACjCW,QAAQ,CAAC,IAAD,CAAR;IACAE,cAAc,CAAC,IAAD,CAAd;EACH,CAH6B,EAG3B,EAH2B,CAA9B;EAKA,OAAO;IAAEL,OAAF;IAAWC,UAAX;IAAuBK,OAAvB;IAAgCJ,KAAhC;IAAuC2B,UAAvC;IAAmDzB;EAAnD,CAAP;AACH,CA/CM;;GAAML,O"},"metadata":{},"sourceType":"module"}